# Mailo Application Scaffolding Guide

This guide provides the EXACT structure and patterns used in Mailo for building NestJS applications with Clean Architecture and DDD principles. Use this to scaffold new applications with the same architecture.

**IMPORTANT**: This guide is for an AI agent to scaffold applications. Some files must be EXACT COPIES from Mailo, while others are generated dynamically based on prompts.

## Table of Contents

1. [Overview](#overview)
2. [Static/Core Files (EXACT COPIES REQUIRED)](#staticcore-files-exact-copies-required)
3. [Feature Module Structure (DYNAMIC - Build from prompts)](#feature-module-structure-dynamic---build-from-prompts)
4. [Scaffolding Instructions](#scaffolding-instructions)
5. [File Generation Rules](#file-generation-rules)

---

## Overview

### Files/Folders to Copy EXACTLY from Mailo:

1. `src/main.ts` - EXACT COPY (update only `APP_NAME`)
2. `src/app.module.ts` - EXACT COPY (update module imports)
3. `src/constant.ts` - EXACT COPY (add tokens as needed)
4. `src/errors.ts` - EXACT COPY
5. `src/config/` - EXACT COPY (update validation schema)
6. `src/orm/` - EXACT COPY (update entities list)
7. `src/utils/` - EXACT COPY (all utilities)
8. `src/auth/` - EXACT COPY (entire directory)
9. `src/shared/` - EXACT COPY (entire directory)

### Files/Folders to Generate Dynamically:

- Feature modules (`src/{featureName}/`) - Build based on prompts
- Feature-specific files (entities, DTOs, use cases, repositories, controllers, mappers)

---

## Project Root Structure

```
project-root/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.ts                           # EXACT COPY - Entry point
â”‚   â”œâ”€â”€ app.module.ts                     # EXACT COPY - Root module
â”‚   â”œâ”€â”€ app.controller.ts                 # Generated by NestJS CLI
â”‚   â”œâ”€â”€ app.service.ts                    # Generated by NestJS CLI
â”‚   â”œâ”€â”€ app.controller.spec.ts            # Generated by NestJS CLI
â”‚   â”‚
â”‚   â”œâ”€â”€ constant.ts                       # EXACT COPY - DI Tokens & Constants
â”‚   â”œâ”€â”€ errors.ts                         # EXACT COPY - Error Classes
â”‚   â”‚
â”‚   â”œâ”€â”€ config/                           # EXACT COPY - Config System
â”‚   â”‚   â”œâ”€â”€ config.module.ts
â”‚   â”‚   â”œâ”€â”€ config.service.ts
â”‚   â”‚   â””â”€â”€ config.validation.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ orm/                              # EXACT COPY - ORM Configuration
â”‚   â”‚   â”œâ”€â”€ database.config.ts
â”‚   â”‚   â””â”€â”€ entities/
â”‚   â”‚       â””â”€â”€ base.entity.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/                            # EXACT COPY - Utility Functions
â”‚   â”‚   â”œâ”€â”€ encryption/
â”‚   â”‚   â”œâ”€â”€ pagination/
â”‚   â”‚   â”œâ”€â”€ generate-code/
â”‚   â”‚   â”œâ”€â”€ generate-uuid/
â”‚   â”‚   â”œâ”€â”€ or-fail/
â”‚   â”‚   â”œâ”€â”€ logger/
â”‚   â”‚   â”œâ”€â”€ permissions/
â”‚   â”‚   â””â”€â”€ ... (all utils)
â”‚   â”‚
â”‚   â”œâ”€â”€ auth/                             # EXACT COPY - Authentication
â”‚   â”‚   â”œâ”€â”€ auth.module.ts
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â””â”€â”€ infrastructure/
â”‚   â”‚
â”‚   â”œâ”€â”€ shared/                           # EXACT COPY - Shared Code
â”‚   â”‚   â”œâ”€â”€ mailer/
â”‚   â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â””â”€â”€ types/
â”‚   â”‚
â”‚   â””â”€â”€ {featureName}/                    # DYNAMIC - Feature Modules
â”‚       â”œâ”€â”€ {featureName}.module.ts
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ application/
â”‚       â””â”€â”€ infrastructure/
```

---

## Static/Core Files (EXACT COPIES REQUIRED)

**CRITICAL**: These files MUST be copied EXACTLY. Use the code snippets provided in `SCAFFOLD_GUIDE_CODE_SNIPPETS.md`.

### Copy Instructions:

1. **For files with code snippets**: Copy the code from `SCAFFOLD_GUIDE_CODE_SNIPPETS.md`
2. **For files marked "Copy from Mailo"**: You need access to Mailo codebase to copy those files
3. Update ONLY the specified values (e.g., `APP_NAME`, module imports, entity lists)
4. Keep ALL other code identical

**IMPORTANT**: A separate file `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` contains the actual code for all EXACT COPY files. Refer to that file for the code snippets.

### 1. `src/main.ts` (EXACT COPY)

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ConfigService } from './config/config.service';
import {
  WINSTON_MODULE_NEST_PROVIDER,
  WINSTON_MODULE_PROVIDER,
} from 'nest-winston';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { patchNestjsSwagger } from '@anatine/zod-nestjs';
import * as cookieParser from 'cookie-parser';

export const APP_NAME = '{APP_NAME}'; // Update this
export const GLOBAL_PREFIX = 'api';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    rawBody: true,
    bodyParser: true,
  });
  const configService = app.get(ConfigService);
  const logger = app.get(WINSTON_MODULE_PROVIDER);

  const version = configService.get('VERSION');
  const env = configService.get('ENV').toUpperCase();
  const port = configService.get('PORT');
  const origin = configService.get('ORIGIN');

  app.setGlobalPrefix(GLOBAL_PREFIX);
  app.useLogger(app.get(WINSTON_MODULE_NEST_PROVIDER));

  // Enable cookie parser middleware
  app.use(cookieParser());

  app.enableCors({
    origin,
    credentials: true,
  });

  if (env === 'DEVELOPMENT') {
    logger.info(`ðŸš€ [${env}] Swagger is enabled`);
    const config = new DocumentBuilder()
      .setTitle(`${APP_NAME.toUpperCase()} API`)
      .setDescription(`${APP_NAME.toUpperCase()} API Documentation`)
      .setVersion(version)
      .addBearerAuth()
      .build();

    patchNestjsSwagger();

    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup(GLOBAL_PREFIX, app, document);
  }

  await app.listen(port);

  logger.info(
    `ðŸš€ [${env}] Application is running on: http://localhost:${port}/${GLOBAL_PREFIX}`,
  );
}
bootstrap();
```

**Instructions:**

- Copy EXACTLY as shown
- Only update `APP_NAME` constant with your application name
- All other code must remain identical

---

### 2. `src/app.module.ts` (EXACT COPY)

**Copy this code EXACTLY. Only update the imports array (add your feature modules).**

```typescript
import { Inject, Module, OnModuleInit } from '@nestjs/common';
import { ScheduleModule } from '@nestjs/schedule';
import {
  ConfigModule,
  ConfigService,
  ConfigModule as NestConfigModule,
} from '@nestjs/config';
import dbConfig from './orm/database.config';
import { APP_GUARD, APP_PIPE } from '@nestjs/core';
import { ZodValidationPipe } from '@anatine/zod-nestjs';
import { WinstonModule } from 'nest-winston';
import { APP_NAME } from './main';
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { MikroORM } from '@mikro-orm/core';
import { CONFIG_SCHEMA } from './config/config.validation';
import { baseLoggerConfig } from './utils/logger';
import { AuthModule } from './auth/auth.module';
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { Token } from './constant';
import { BullModule } from '@nestjs/bullmq';
import { JwtAuthGuard } from '@auth/infrastructure/guards';
import { UsersModule } from '@user/users.module';
// ADD YOUR FEATURE MODULES HERE

@Module({
  imports: [
    ScheduleModule.forRoot(),
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get('JWT_SECRET') || 'fallback-secret',
        signOptions: { expiresIn: '1d' },
      }),
      global: true, // MUST be global
    }),
    NestConfigModule.forRoot({
      validate: (config) =>
        CONFIG_SCHEMA.parse({ ...config, VERSION: config.npm_package_version }),
      isGlobal: true, // MUST be global
    }),
    WinstonModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => {
        const env = configService.get('ENV')?.toLowerCase();
        const logLevel = env === 'development' ? 'debug' : 'info';
        return baseLoggerConfig(APP_NAME, logLevel);
      },
    }),
    MikroOrmModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => {
        return {
          ...dbConfig,
          host: configService.get('DB_HOST'),
          dbName: configService.get('DB_NAME'),
          user: configService.get('DB_USER'),
          password: configService.get('DB_PASSWORD'),
          port: configService.get('DB_PORT'),
        };
      },
    }),
    AuthModule,
    ConfigModule,
    // ADD YOUR FEATURE MODULES HERE
    BullModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => {
        const connection: any = {
          host: configService.get('REDIS_HOST'),
          port: Number(configService.get('REDIS_PORT')),
        };

        const password = configService.get<string>('REDIS_PASSWORD');
        const username = configService.get<string>('REDIS_USER');

        if (
          password &&
          typeof password === 'string' &&
          password.trim().length > 0 &&
          password.trim() !== 'undefined' &&
          password.trim() !== 'null'
        ) {
          connection.password = password.trim();
        }

        if (
          username &&
          typeof username === 'string' &&
          username.trim().length > 0 &&
          username.trim() !== 'undefined' &&
          username.trim() !== 'null'
        ) {
          connection.user = username.trim();
        }

        return {
          connection,
          defaultJobOptions: {
            attempts: 3,
            removeOnComplete: true,
            removeOnFail: false,
          },
        };
      },
      inject: [ConfigService],
    }),
    UsersModule, // Example - add your modules
  ],
  providers: [
    { provide: APP_GUARD, useClass: JwtAuthGuard },
    {
      provide: APP_PIPE,
      useClass: ZodValidationPipe,
    },
  ],
})
export class AppModule implements OnModuleInit {
  constructor(
    private readonly orm: MikroORM,
    private readonly configService: ConfigService,
    @Inject(Token.Logger)
    private readonly logger: { info: (message: string) => void },
  ) {}

  async onModuleInit() {
    const environment = this.configService.get('ENV').toUpperCase();

    this.logger.info(`[APP] Running migrations in ${environment} environment`);

    if (environment === 'DEVELOPMENT') {
      const generator = this.orm.getSchemaGenerator();
      this.logger.info(`[${environment} DB] Checking database schema...`);
      await generator.ensureDatabase();
      await generator.updateSchema();
      this.logger.info(`[${environment} DB] Database schema is up to date.`);
    }

    if (environment === 'PRODUCTION') {
      const migrator = this.orm.getMigrator();
      this.logger.info(`[${environment} DB] Running migrations...`);
      await migrator.up();
      this.logger.info(`[${environment} DB] Migrations are done.`);
    }
  }
}
```

**Instructions:**

- Copy this code EXACTLY
- Add your feature modules to the `imports` array
- Keep all configuration exactly the same

---

### 3. `src/constant.ts` (EXACT COPY)

Copy the ENTIRE `constant.ts` file from Mailo.

**Instructions:**

- Copy EXACTLY as-is
- Add new repository tokens for new features: `{FeatureName}Repository: Symbol('{FeatureName}Repository')`
- Keep all existing constants (EMAIL_PROVIDERS, ROTATION_RULES, WARMUP_SESSION_STAGES, Notifications)

---

### 4. `src/errors.ts` (EXACT COPY)

Copy the ENTIRE `errors.ts` file from Mailo.

**Instructions:**

- Copy EXACTLY as-is
- Do NOT modify error classes
- Keep all error types: `NotFoundError`, `ConflictError`, `ProcessingError`, `BadRequestError`, `UnauthorizedError`, `AlreadyExistsError`

---

### 5. `src/config/` (EXACT COPY)

**See:** `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` section 5 for complete code.

**Files:**

- `config.module.ts` - See code snippets file
- `config.service.ts` - See code snippets file
- `config.validation.ts` - See code snippets file (update schema as needed)

**Instructions:**

- Copy code from `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` section 5
- For `config.validation.ts`: Update schema fields based on your app needs
- Keep the pattern: `zod` schema validation, `ConfigService` wrapper

---

### 6. `src/orm/` (EXACT COPY)

**See:** `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` section 6 for complete code.

**Files:**

- `database.config.ts` - See code snippets file (update entities list)
- `entities/base.entity.ts` - See code snippets file

**Instructions:**

- Copy code from `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` section 6
- For `database.config.ts`: Update `entities` array with your entities
- Keep all configuration: `SeedManager`, `Migrator`, `SqlHighlighter`, migration paths

---

### 7. `src/utils/` (EXACT COPY)

**See:** `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` section 7 for complete code.

**Key files:**

- `logger/index.ts` - See code snippets file
- `pagination/index.ts` - See code snippets file
- `pagination/schema.ts` - See code snippets file
- `generate-code/index.ts` - See code snippets file
- `generate-uuid/index.ts` - See code snippets file
- `or-fail/index.ts` - See code snippets file
- `nullish-or-fail/index.ts` - See code snippets file
- `transaction/index.ts` - See code snippets file
- `schemas/zod/index.ts` - See code snippets file
- `encryption/index.ts` - See code snippets file
- `permissions/index.ts` - Copy entire file from Mailo (very long)

**Instructions:**

- Copy code from `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` section 7
- Copy `permissions/index.ts` from Mailo (too long to include)
- Do NOT modify utility implementations
- Each utility follows the pattern: `src/utils/{utilityName}/index.ts`

---

### 8. `src/auth/` (EXACT COPY - CRITICAL)

**IMPORTANT:** Copy the ENTIRE `auth/` directory from Mailo. See `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` section 9 for critical files.

**Structure:**

```
src/auth/
â”œâ”€â”€ auth.module.ts            # Copy from Mailo
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ dto/
â”‚   â””â”€â”€ use-cases/
â”œâ”€â”€ domain/
â”‚   â””â”€â”€ interfaces/
â””â”€â”€ infrastructure/
    â”œâ”€â”€ adapters/
    â”‚   â””â”€â”€ outbound/jwt/
    â”‚       â””â”€â”€ jwt.strategy.ts  # CRITICAL - Copy from Mailo
    â”œâ”€â”€ decorators/
    â”‚   â”œâ”€â”€ public.decorator.ts  # See code snippets
    â”‚   â”œâ”€â”€ user.decorator.ts    # Copy from Mailo
    â”‚   â””â”€â”€ permissions.decorator.ts  # Copy from Mailo
    â”œâ”€â”€ guards/
    â”‚   â”œâ”€â”€ jwt-auth.guard.ts    # CRITICAL - Copy from Mailo
    â”‚   â””â”€â”€ permissions.guard.ts # CRITICAL - Copy from Mailo
    â””â”€â”€ services/
```

**Instructions:**

- Copy the ENTIRE `auth/` directory from Mailo
- Keep all JWT strategy, guards, decorators (@Public, @User, @Permissions)
- Update only imports if module paths change
- All auth files must remain EXACT copies
- See `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` section 9 for structure reference

---

### 9. `src/shared/` (EXACT COPY)

**See:** `SCAFFOLD_GUIDE_CODE_SNIPPETS.md` section 8 for key files.

**Files:**

- `core/result.ts` - See code snippets file
- `types/index.ts` - Copy from Mailo
- `mailer/` - Copy entire directory from Mailo if you need email functionality

**Instructions:**

- Copy `core/result.ts` from code snippets file
- Copy `types/index.ts` from Mailo
- Copy `mailer/` directory from Mailo if needed
- Keep all shared code EXACTLY

---

## Feature Module Structure (Dynamic)

For each new feature module, create the following structure. Replace `{featureName}` with your feature name (camelCase) and `{FeatureName}` with PascalCase.

### Feature Directory Structure

```
src/{featureName}/
â”œâ”€â”€ {featureName}.module.ts              # NestJS module
â”‚
â”œâ”€â”€ domain/                              # Domain Layer
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â””â”€â”€ {featureName}.entity.ts      # Domain entity
â”‚   â”œâ”€â”€ ports/
â”‚   â”‚   â””â”€â”€ {featureName}.repository.port.ts  # Repository interface
â”‚   â”œâ”€â”€ value-objects/                   # Optional
â”‚   â”‚   â””â”€â”€ {valueObject}.vo.ts
â”‚   â””â”€â”€ exceptions/                      # Optional
â”‚       â””â”€â”€ {exception}.exception.ts
â”‚
â”œâ”€â”€ application/                         # Application Layer
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”œâ”€â”€ create-{featureName}/
â”‚   â”‚   â”‚   â”œâ”€â”€ schema.ts                # Zod schema
â”‚   â”‚   â”‚   â”œâ”€â”€ dto.ts                   # NestJS DTO
â”‚   â”‚   â”‚   â””â”€â”€ index.ts                 # Exports
â”‚   â”‚   â”œâ”€â”€ update-{featureName}/
â”‚   â”‚   â”‚   â”œâ”€â”€ schema.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ dto.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ get-{featureName}s-paginated/
â”‚   â”‚       â”œâ”€â”€ schema.ts
â”‚   â”‚       â”œâ”€â”€ dto.ts
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ use-cases/
â”‚   â”‚   â”œâ”€â”€ create-{featureName}.use-case.ts
â”‚   â”‚   â”œâ”€â”€ update-{featureName}.use-case.ts
â”‚   â”‚   â”œâ”€â”€ delete-{featureName}.use-case.ts
â”‚   â”‚   â”œâ”€â”€ get-{featureName}-by-id.use-case.ts
â”‚   â”‚   â”œâ”€â”€ get-{featureName}s-paginated.use-case.ts
â”‚   â”‚   â””â”€â”€ index.ts                     # Export all use cases
â”‚   â”‚
â”‚   â””â”€â”€ services/                        # Optional
â”‚       â””â”€â”€ {serviceName}.service.ts
â”‚
â””â”€â”€ infrastructure/                      # Infrastructure Layer
    â”œâ”€â”€ adapters/
    â”‚   â”œâ”€â”€ inbound/
    â”‚   â”‚   â””â”€â”€ http/
    â”‚   â”‚       â””â”€â”€ {featureName}s.controller.ts
    â”‚   â””â”€â”€ outbound/
    â”‚       â””â”€â”€ persistence/
    â”‚           â””â”€â”€ {featureName}.repository.ts
    â”‚
    â”œâ”€â”€ entities/
    â”‚   â””â”€â”€ {featureName}.entity.ts      # MikroORM entity
    â”‚
    â””â”€â”€ mappers/
        â””â”€â”€ {featureName}.mapper.ts      # Domain â†” Infrastructure mapper
```

---

### 1. Feature Module File (`{featureName}.module.ts`)

```typescript
import { Module } from '@nestjs/common';
import { {FeatureName}sController } from './infrastructure/adapters/inbound/http/{featureName}s.controller';
import { Token } from 'src/constant';
import { {FeatureName}Repository } from './infrastructure/adapters/outbound/persistence/{featureName}.repository';
import {
  Create{FeatureName}UseCase,
  Update{FeatureName}UseCase,
  Get{FeatureName}ByIdUseCase,
  Get{FeatureName}sPaginatedUseCase,
} from './application/use-cases';
import { {FeatureName}Mapper } from './infrastructure/mappers/{featureName}.mapper';

@Module({
  controllers: [{FeatureName}sController],
  providers: [
    Create{FeatureName}UseCase,
    Update{FeatureName}UseCase,
    Get{FeatureName}ByIdUseCase,
    Get{FeatureName}sPaginatedUseCase,
    {FeatureName}Mapper,
    {
      provide: Token.{FeatureName}Repository,
      useClass: {FeatureName}Repository,
    },
  ],
  exports: [
    Token.{FeatureName}Repository,
    Get{FeatureName}ByIdUseCase,
  ],
})
export class {FeatureName}Module {}
```

**Instructions:**

- Replace `{featureName}` with camelCase (e.g., `user`, `emailAccount`)
- Replace `{FeatureName}` with PascalCase (e.g., `User`, `EmailAccount`)
- Add imports for other modules if needed
- Add providers for use cases, mappers, repositories
- Export what other modules might need

---

### 2. Domain Entity (`domain/entities/{featureName}.entity.ts`)

```typescript
export type {FeatureName}Proto = {
  id?: string;
  // Add your properties
  createdAt?: Date;
  updatedAt?: Date;
};

export type {FeatureName}JSON = {
  id: string;
  // Add your properties
  createdAt: Date;
  updatedAt: Date;
};

export class {FeatureName} {
  private readonly _id?: string;
  // Add private fields

  constructor(proto: {FeatureName}Proto) {
    this._id = proto.id;
    // Initialize properties
  }

  get id(): string {
    return this._id;
  }

  // Add business logic methods

  toJSON(): {FeatureName}JSON {
    return {
      id: this._id,
      // Map properties
      createdAt: this._createdAt,
      updatedAt: this._updatedAt,
    };
  }
}
```

**Instructions:**

- Use private fields with underscore prefix (`_id`, `_name`)
- Use readonly for immutable fields
- Add getters for read-only access
- Add business logic methods (activate, update, etc.)
- Include `toJSON()` method

---

### 3. Repository Port (`domain/ports/{featureName}.repository.port.ts`)

```typescript
import { {FeatureName} } from '../entities/{featureName}.entity';
import { Page } from 'src/utils/pagination';

export type Get{FeatureName}sPaginatedOptions = {
  limit: number;
  offset: number;
  // Add filter options
};

export interface I{FeatureName}Repository {
  create({featureName}: {FeatureName}): Promise<{FeatureName}>;
  update({featureName}: {FeatureName}): Promise<void>;
  delete(id: string): Promise<void>;
  getById(id: string): Promise<{FeatureName} | null>;
  getAll(opts: Get{FeatureName}sPaginatedOptions): Promise<Page<{FeatureName}>>;
}
```

**Instructions:**

- Define interface with standard CRUD methods
- Use domain entities, not infrastructure entities
- Use `Page<T>` from `src/utils/pagination`
- Add custom methods as needed

---

### 4. DTO Schema (`application/dto/create-{featureName}/schema.ts`)

```typescript
import z from 'zod';

export const CREATE_{FEATURE_NAME}_SCHEMA = z.strictObject({
  // Add your fields with validation
  name: z.string().min(3).max(255),
  email: z.string().email().optional(),
});

export type Create{FeatureName}Input = z.input<typeof CREATE_{FEATURE_NAME}_SCHEMA>;
export type Create{FeatureName}Transformed = z.output<typeof CREATE_{FEATURE_NAME}_SCHEMA>;
```

**Instructions:**

- Use `z.strictObject()` to prevent extra fields
- Use `z.input<>` and `z.output<>` for type safety
- Export schema name in UPPER_SNAKE_CASE
- Add validation rules (min, max, email, etc.)

---

### 5. DTO Class (`application/dto/create-{featureName}/dto.ts`)

```typescript
import { createZodDto } from '@anatine/zod-nestjs';
import { extendApi } from '@anatine/zod-openapi';
import { CREATE_{FEATURE_NAME}_SCHEMA } from './schema';

export class Create{FeatureName}Dto extends createZodDto(
  extendApi(CREATE_{FEATURE_NAME}_SCHEMA),
) {}
```

**Instructions:**

- Use `createZodDto` from `@anatine/zod-nestjs`
- Use `extendApi` from `@anatine/zod-openapi`
- Extend the schema

---

### 6. DTO Index (`application/dto/create-{featureName}/index.ts`)

```typescript
export * from './dto';
export * from './schema';
```

**Instructions:**

- Export schema and DTO
- Keep it simple

---

### 7. Use Case (`application/use-cases/create-{featureName}.use-case.ts`)

```typescript
import { Inject, Injectable } from '@nestjs/common';
import { {FeatureName} } from '@{featureName}/domain/entities/{featureName}.entity';
import { I{FeatureName}Repository } from '@{featureName}/domain/ports/{featureName}.repository.port';
import { Token } from 'src/constant';
import { Create{FeatureName}Transformed } from '../dto/create-{featureName}';
import { ConflictError } from 'src/errors';

@Injectable()
export class Create{FeatureName}UseCase {
  constructor(
    @Inject(Token.{FeatureName}Repository)
    private readonly {featureName}Repository: I{FeatureName}Repository,
  ) {}

  async handle(payload: Create{FeatureName}Transformed): Promise<{FeatureName}> {
    // 1. Check if already exists (if applicable)
    const existing = await this.{featureName}Repository.getById(/* check logic */);
    if (existing) {
      throw new ConflictError('{FeatureName} already exists');
    }

    // 2. Create domain entity
    const {featureName} = new {FeatureName}({
      ...payload,
    });

    // 3. Persist
    const created = await this.{featureName}Repository.create({featureName});

    // 4. Return
    return created;
  }
}
```

**Instructions:**

- Use `@Injectable()` decorator
- Inject repository using `Token.{FeatureName}Repository`
- Use domain entities, not infrastructure
- Use error classes from `src/errors`
- Follow pattern: validate â†’ create entity â†’ persist â†’ return

---

### 8. Use Cases Index (`application/use-cases/index.ts`)

```typescript
export * from './create-{featureName}.use-case';
export * from './update-{featureName}.use-case';
export * from './get-{featureName}-by-id.use-case';
export * from './get-{featureName}s-paginated.use-case';
```

**Instructions:**

- Export all use cases
- Keep alphabetical or logical order

---

### 9. Infrastructure Entity (`infrastructure/entities/{featureName}.entity.ts`)

```typescript
import {
  Entity,
  Property,
} from '@mikro-orm/core';
import { BaseEntity } from 'src/orm/entities/base.entity';

export type {FeatureName}EntityProps = {
  id?: string;
  // Add your properties
};

@Entity({ tableName: '{featureName}s' })
export class {FeatureName}Entity extends BaseEntity implements {FeatureName}EntityProps {
  @Property({ length: 255 })
  name!: string;

  // Add more properties with decorators

  constructor(props: {FeatureName}EntityProps) {
    super();
    this.id = props.id;
    this.name = props.name;
    // Initialize properties
  }
}
```

**Instructions:**

- Extend `BaseEntity` from `src/orm/entities/base.entity`
- Use MikroORM decorators (`@Entity`, `@Property`, etc.)
- Use table name: `{featureName}s` (plural)
- Implement entity props type
- Initialize in constructor

---

### 10. Repository Implementation (`infrastructure/adapters/outbound/persistence/{featureName}.repository.ts`)

```typescript
import {
  EntityManager,
  EntityRepository,
  FilterQuery,
} from '@mikro-orm/postgresql';
import { Injectable } from '@nestjs/common';
import { {FeatureName} } from '@{featureName}/domain/entities/{featureName}.entity';
import {
  Get{FeatureName}sPaginatedOptions,
  I{FeatureName}Repository,
} from '@{featureName}/domain/ports/{featureName}.repository.port';
import { {FeatureName}Entity } from '@{featureName}/infrastructure/entities/{featureName}.entity';
import { {FeatureName}Mapper } from '@{featureName}/infrastructure/mappers/{featureName}.mapper';
import { Page, paginate } from 'src/utils/pagination';

@Injectable()
export class {FeatureName}Repository implements I{FeatureName}Repository {
  private readonly dbSource: EntityRepository<{FeatureName}Entity>;

  constructor(
    private readonly mapper: {FeatureName}Mapper,
    private readonly em: EntityManager,
  ) {
    this.dbSource = this.em.getRepository({FeatureName}Entity);
  }

  async create({featureName}: {FeatureName}): Promise<{FeatureName}> {
    const entity = this.mapper.toEntity({featureName});
    this.em.persist(entity);
    await this.em.flush();
    return this.mapper.toDomain(entity);
  }

  async update({featureName}: {FeatureName}): Promise<void> {
    await this.dbSource.nativeUpdate(
      { id: {featureName}.id },
      this.mapper.toEntity({featureName}),
    );
  }

  async delete(id: string): Promise<void> {
    await this.dbSource.nativeDelete({ id });
  }

  async getById(id: string): Promise<{FeatureName} | null> {
    const entity = await this.dbSource.findOne({ id });
    return entity ? this.mapper.toDomain(entity) : null;
  }

  async getAll(opts: Get{FeatureName}sPaginatedOptions): Promise<Page<{FeatureName}>> {
    const filters: FilterQuery<{FeatureName}Entity> = {};
    // Add filters based on opts

    const [entities, totalCount] = await this.dbSource.findAndCount(
      filters,
      {
        limit: opts.limit,
        offset: opts.offset,
      },
    );

    return paginate(
      entities.map((entity) => this.mapper.toDomain(entity)),
      { totalCount, limit: opts.limit, offset: opts.offset },
    );
  }
}
```

**Instructions:**

- Use `EntityManager` and `EntityRepository` from MikroORM
- Use mapper to convert domain â†” infrastructure
- Use `paginate` utility from `src/utils/pagination`
- For `nativeUpdate`: Remove relationship properties before updating (if needed)
- Follow repository interface exactly

---

### 11. Mapper (`infrastructure/mappers/{featureName}.mapper.ts`)

```typescript
import { Injectable } from '@nestjs/common';
import { {FeatureName} } from '@{featureName}/domain/entities/{featureName}.entity';
import { {FeatureName}Entity } from '@{featureName}/infrastructure/entities/{featureName}.entity';

@Injectable()
export class {FeatureName}Mapper {
  toDomain(entity: {FeatureName}Entity): {FeatureName} {
    return new {FeatureName}({
      id: entity.id,
      // Map properties
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt,
    });
  }

  toEntity({featureName}: {FeatureName}): {FeatureName}Entity {
    return new {FeatureName}Entity({
      id: {featureName}.id,
      // Map properties
    });
  }
}
```

**Instructions:**

- Use `@Injectable()` decorator
- Convert domain entity â†” infrastructure entity
- Map all properties
- Handle relationships if needed

---

### 12. Controller (`infrastructure/adapters/inbound/http/{featureName}s.controller.ts`)

```typescript
import { AuthUser } from '@auth/domain/interfaces';
import { User } from '@auth/infrastructure/decorators';
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  Put,
  Query,
} from '@nestjs/common';
import { Create{FeatureName}Dto } from '@{featureName}/application/dto/create-{featureName}';
import { Update{FeatureName}Dto } from '@{featureName}/application/dto/update-{featureName}';
import { Get{FeatureName}sPaginatedDto } from '@{featureName}/application/dto/get-{featureName}s-paginated';
import {
  Create{FeatureName}UseCase,
  Update{FeatureName}UseCase,
  Delete{FeatureName}UseCase,
  Get{FeatureName}ByIdUseCase,
  Get{FeatureName}sPaginatedUseCase,
} from '@{featureName}/application/use-cases';

@Controller('{featureName}s')
export class {FeatureName}sController {
  constructor(
    private readonly create{FeatureName}UseCase: Create{FeatureName}UseCase,
    private readonly update{FeatureName}UseCase: Update{FeatureName}UseCase,
    private readonly delete{FeatureName}UseCase: Delete{FeatureName}UseCase,
    private readonly get{FeatureName}ByIdUseCase: Get{FeatureName}ByIdUseCase,
    private readonly get{FeatureName}sPaginatedUseCase: Get{FeatureName}sPaginatedUseCase,
  ) {}

  @Post()
  async create(@Body() body: Create{FeatureName}Dto) {
    return await this.create{FeatureName}UseCase.handle(body);
  }

  @Get(':id')
  async getById(@Param('id') id: string) {
    return await this.get{FeatureName}ByIdUseCase.handle(id);
  }

  @Get()
  async getAll(@Query() opts: Get{FeatureName}sPaginatedDto) {
    return await this.get{FeatureName}sPaginatedUseCase.handle(opts);
  }

  @Put(':id')
  async update(@Param('id') id: string, @Body() body: Update{FeatureName}Dto) {
    return await this.update{FeatureName}UseCase.handle(body, id);
  }

  @Delete(':id')
  async delete(@Param('id') id: string) {
    return await this.delete{FeatureName}UseCase.handle(id);
  }
}
```

**Instructions:**

- Use plural controller name: `{FeatureName}sController`
- Use `@Controller('{featureName}s')` with plural
- Inject all use cases
- Use DTOs for validation
- Use `@User()` decorator if user context needed
- Follow RESTful conventions

---

## Scaffolding Instructions

### Step 1: Setup Static/Core Files

1. **Copy `main.ts`** - Update only `APP_NAME`
2. **Copy `app.module.ts`** - Update module imports
3. **Copy `constant.ts`** - Add repository tokens as needed
4. **Copy `errors.ts`** - Keep as-is
5. **Copy `config/`** - Update validation schema
6. **Copy `orm/`** - Update entities list in `database.config.ts`
7. **Copy `utils/`** - Keep all utilities
8. **Copy `auth/`** - Keep entire auth structure
9. **Copy `shared/`** - Keep all shared code

### Step 2: Create Feature Modules

For each feature, create the structure following the patterns above:

1. Create feature directory: `src/{featureName}/`
2. Create domain layer files
3. Create application layer files (DTOs, use cases)
4. Create infrastructure layer files (entities, repositories, mappers, controllers)
5. Create module file
6. Add module to `app.module.ts`
7. Add repository token to `constant.ts`
8. Add entity to `orm/database.config.ts`

### Step 3: Update App Module

Add your feature modules to `app.module.ts` imports:

```typescript
imports: [
  // ... existing modules
  {FeatureName}Module,
],
```

### Step 4: Update Constants

Add repository token to `src/constant.ts`:

```typescript
export const Token = {
  // ... existing tokens
  {FeatureName}Repository: Symbol('{FeatureName}Repository'),
};
```

### Step 5: Update ORM Config

Add entity to `src/orm/database.config.ts`:

```typescript
import { {FeatureName}Entity } from '@{featureName}/infrastructure/entities/{featureName}.entity';

export const config = defineConfig({
  entities: [
    // ... existing entities
    {FeatureName}Entity,
  ],
});
```

---

## Key Patterns to Follow

### Naming Conventions

- **Feature name**: camelCase (`user`, `emailAccount`, `warmupSession`)
- **Class names**: PascalCase (`User`, `EmailAccount`, `WarmupSession`)
- **File names**: kebab-case (`user.entity.ts`, `email-account.entity.ts`)
- **Controller**: Plural (`UsersController`, `EmailAccountsController`)
- **Route**: Plural (`/users`, `/email-accounts`)
- **Module**: Singular (`UsersModule`, `EmailAccountsModule`)

### Path Aliases

Use path aliases in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "paths": {
      "@{featureName}/*": ["src/{featureName}/*"],
      "src/*": ["src/*"]
    }
  }
}
```

### Dependency Injection

- Use `Token.{FeatureName}Repository` for repositories
- Use `@Inject(Token.{FeatureName}Repository)` in use cases
- Provide repository in module with `useClass`
- Always use interfaces from domain layer

### Error Handling

- Use error classes from `src/errors`
- `NotFoundError` - Entity not found
- `ConflictError` - Already exists / Conflict
- `ProcessingError` - Business logic errors
- `BadRequestError` - Invalid input
- `UnauthorizedError` - Authentication/Authorization

### Validation

- Use Zod schemas in DTOs
- Use `z.strictObject()` to prevent extra fields
- Use `createZodDto` for NestJS DTO classes
- Use `extendApi` for OpenAPI/Swagger

---

## Example: Creating a "Product" Feature

Given prompt: "Create a product feature with name, description, price"

### Files to Create:

1. `src/product/product.module.ts`
2. `src/product/domain/entities/product.entity.ts`
3. `src/product/domain/ports/product.repository.port.ts`
4. `src/product/application/dto/create-product/schema.ts`
5. `src/product/application/dto/create-product/dto.ts`
6. `src/product/application/dto/create-product/index.ts`
7. `src/product/application/use-cases/create-product.use-case.ts`
8. `src/product/application/use-cases/index.ts`
9. `src/product/infrastructure/entities/product.entity.ts`
10. `src/product/infrastructure/adapters/outbound/persistence/product.repository.ts`
11. `src/product/infrastructure/mappers/product.mapper.ts`
12. `src/product/infrastructure/adapters/inbound/http/products.controller.ts`

### Updates:

1. Add `ProductRepository: Symbol('ProductRepository')` to `constant.ts`
2. Add `ProductModule` to `app.module.ts` imports
3. Add `ProductEntity` to `orm/database.config.ts` entities array

---

## Notes

- **DO NOT** modify static/core files except for app-specific updates (module names, entity lists)
- **DO** follow the exact patterns shown for feature modules
- **DO** use the exact same utility functions and error classes
- **DO** maintain the same folder structure
- **DO** use the same naming conventions
- **DO** follow the same dependency injection patterns
- **DO** use the same validation and error handling patterns

This guide ensures you scaffold applications with the EXACT same architecture as Mailo.
